{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"C:/Users/Brandon/Projects/3x3-monte-dapp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Brandon/Projects/3x3-monte-dapp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nvar logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  var errors = [];\n\n  var checkErrors = function checkErrors(path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n\n    for (var key in object) {\n      var childPath = path.slice();\n      childPath.push(key);\n\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n\n  checkErrors([], result);\n  return errors;\n}\nexport var Coder = /*#__PURE__*/function () {\n  function Coder(name, type, localName, dynamic) {\n    _classCallCheck(this, Coder);\n\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message, value) {\n      logger.throwArgumentError(message, this.localName, value);\n    }\n  }]);\n\n  return Coder;\n}();\nexport var Writer = /*#__PURE__*/function () {\n  function Writer(wordSize) {\n    _classCallCheck(this, Writer);\n\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n\n  _createClass(Writer, [{\n    key: \"data\",\n    get: function get() {\n      return hexConcat(this._data);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._dataLength;\n    }\n  }, {\n    key: \"_writeData\",\n    value: function _writeData(data) {\n      this._data.push(data);\n\n      this._dataLength += data.length;\n      return data.length;\n    }\n  }, {\n    key: \"appendWriter\",\n    value: function appendWriter(writer) {\n      return this._writeData(concat(writer._data));\n    } // Arrayish items; padded on the right to wordSize\n\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(value) {\n      var bytes = arrayify(value);\n      var paddingOffset = bytes.length % this.wordSize;\n\n      if (paddingOffset) {\n        bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n      }\n\n      return this._writeData(bytes);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(value) {\n      var bytes = arrayify(BigNumber.from(value));\n\n      if (bytes.length > this.wordSize) {\n        logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this.wordSize,\n          offset: bytes.length\n        });\n      }\n\n      if (bytes.length % this.wordSize) {\n        bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n      }\n\n      return bytes;\n    } // BigNumberish items; padded on the left to wordSize\n\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      return this._writeData(this._getValue(value));\n    }\n  }, {\n    key: \"writeUpdatableValue\",\n    value: function writeUpdatableValue() {\n      var _this = this;\n\n      var offset = this._data.length;\n\n      this._data.push(this._padding);\n\n      this._dataLength += this.wordSize;\n      return function (value) {\n        _this._data[offset] = _this._getValue(value);\n      };\n    }\n  }]);\n\n  return Writer;\n}();\nexport var Reader = /*#__PURE__*/function () {\n  function Reader(data, wordSize, coerceFunc, allowLoose) {\n    _classCallCheck(this, Reader);\n\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n\n  _createClass(Reader, [{\n    key: \"data\",\n    get: function get() {\n      return hexlify(this._data);\n    }\n  }, {\n    key: \"consumed\",\n    get: function get() {\n      return this._offset;\n    } // The default Coerce function\n\n  }, {\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      if (this._coerceFunc) {\n        return this._coerceFunc(name, value);\n      }\n\n      return Reader.coerce(name, value);\n    }\n  }, {\n    key: \"_peekBytes\",\n    value: function _peekBytes(offset, length, loose) {\n      var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\n      if (this._offset + alignedLength > this._data.length) {\n        if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n          alignedLength = length;\n        } else {\n          logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n            length: this._data.length,\n            offset: this._offset + alignedLength\n          });\n        }\n      }\n\n      return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n  }, {\n    key: \"subReader\",\n    value: function subReader(offset) {\n      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(length, loose) {\n      var bytes = this._peekBytes(0, length, !!loose);\n\n      this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?\n\n      return bytes.slice(0, length);\n    }\n  }, {\n    key: \"readValue\",\n    value: function readValue() {\n      return BigNumber.from(this.readBytes(this.wordSize));\n    }\n  }], [{\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      var match = name.match(\"^u?int([0-9]+)$\");\n\n      if (match && parseInt(match[1]) <= 48) {\n        value = value.toNumber();\n      }\n\n      return value;\n    }\n  }]);\n\n  return Reader;\n}();","map":{"version":3,"mappings":"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","names":["arrayify","concat","hexConcat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","checkResultErrors","result","errors","checkErrors","path","object","Array","isArray","key","childPath","slice","push","error","Coder","name","type","localName","dynamic","message","value","throwArgumentError","Writer","wordSize","_data","_dataLength","_padding","Uint8Array","data","length","writer","_writeData","bytes","paddingOffset","from","throwError","BUFFER_OVERRUN","offset","_getValue","Reader","coerceFunc","allowLoose","_offset","_coerceFunc","coerce","loose","alignedLength","Math","ceil","_peekBytes","readBytes","match","parseInt","toNumber"],"sources":["C:\\Users\\Brandon\\Projects\\3x3-monte-dapp\\node_modules\\@ethersproject\\abi\\src.ts\\coders\\abstract-coder.ts"],"sourcesContent":["\"use strict\";\r\n\r\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"../_version\";\r\nconst logger = new Logger(version);\r\n\r\nexport interface Result extends ReadonlyArray<any> {\r\n    readonly [key: string]: any;\r\n}\r\n\r\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\r\n    // Find the first error (if any)\r\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\r\n\r\n    const checkErrors = function(path: Array<string | number>, object: any): void {\r\n        if (!Array.isArray(object)) { return; }\r\n        for (let key in object) {\r\n            const childPath = path.slice();\r\n            childPath.push(key);\r\n\r\n            try {\r\n                 checkErrors(childPath, object[key]);\r\n            } catch (error) {\r\n                errors.push({ path: childPath, error: error });\r\n            }\r\n        }\r\n    }\r\n    checkErrors([ ], result);\r\n\r\n    return errors;\r\n\r\n}\r\n\r\nexport type CoerceFunc = (type: string, value: any) => any;\r\n\r\nexport abstract class Coder {\r\n\r\n    // The coder name:\r\n    //   - address, uint256, tuple, array, etc.\r\n    readonly name: string;\r\n\r\n    // The fully expanded type, including composite types:\r\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\r\n    readonly type: string;\r\n\r\n    // The localName bound in the signature, in this example it is \"baz\":\r\n    //   - tuple(address foo, uint bar) baz\r\n    readonly localName: string;\r\n\r\n    // Whether this type is dynamic:\r\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\r\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\r\n    readonly dynamic: boolean;\r\n\r\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\r\n        // @TODO: defineReadOnly these\r\n        this.name = name;\r\n        this.type = type;\r\n        this.localName = localName;\r\n        this.dynamic = dynamic;\r\n    }\r\n\r\n    _throwError(message: string, value: any): void {\r\n        logger.throwArgumentError(message, this.localName, value);\r\n    }\r\n\r\n    abstract encode(writer: Writer, value: any): number;\r\n    abstract decode(reader: Reader): any;\r\n\r\n    abstract defaultValue(): any;\r\n}\r\n\r\nexport class Writer {\r\n    readonly wordSize: number;\r\n\r\n    _data: Array<Uint8Array>;\r\n    _dataLength: number;\r\n    _padding: Uint8Array;\r\n\r\n    constructor(wordSize?: number) {\r\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\r\n        this._data = [ ];\r\n        this._dataLength = 0;\r\n        this._padding = new Uint8Array(wordSize);\r\n    }\r\n\r\n    get data(): string {\r\n        return hexConcat(this._data);\r\n    }\r\n    get length(): number { return this._dataLength; }\r\n\r\n    _writeData(data: Uint8Array): number {\r\n        this._data.push(data);\r\n        this._dataLength += data.length;\r\n        return data.length;\r\n    }\r\n\r\n    appendWriter(writer: Writer): number {\r\n        return this._writeData(concat(writer._data));\r\n    }\r\n\r\n    // Arrayish items; padded on the right to wordSize\r\n    writeBytes(value: BytesLike): number {\r\n        let bytes = arrayify(value);\r\n        const paddingOffset = bytes.length % this.wordSize;\r\n        if (paddingOffset) {\r\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\r\n        }\r\n        return this._writeData(bytes);\r\n    }\r\n\r\n    _getValue(value: BigNumberish): Uint8Array {\r\n        let bytes = arrayify(BigNumber.from(value));\r\n        if (bytes.length > this.wordSize) {\r\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\r\n                length: this.wordSize,\r\n                offset: bytes.length\r\n            });\r\n        }\r\n        if (bytes.length % this.wordSize) {\r\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\r\n        }\r\n        return bytes;\r\n    }\r\n\r\n    // BigNumberish items; padded on the left to wordSize\r\n    writeValue(value: BigNumberish): number {\r\n        return this._writeData(this._getValue(value));\r\n    }\r\n\r\n    writeUpdatableValue(): (value: BigNumberish) => void {\r\n        const offset = this._data.length;\r\n        this._data.push(this._padding);\r\n        this._dataLength += this.wordSize;\r\n        return (value: BigNumberish) => {\r\n            this._data[offset] = this._getValue(value);\r\n        };\r\n    }\r\n}\r\n\r\nexport class Reader {\r\n    readonly wordSize: number;\r\n    readonly allowLoose: boolean;\r\n\r\n    readonly _data: Uint8Array;\r\n    readonly _coerceFunc: CoerceFunc;\r\n\r\n    _offset: number;\r\n\r\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\r\n        defineReadOnly(this, \"_data\", arrayify(data));\r\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\r\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\r\n        defineReadOnly(this, \"allowLoose\", allowLoose);\r\n\r\n        this._offset = 0;\r\n    }\r\n\r\n    get data(): string { return hexlify(this._data); }\r\n    get consumed(): number { return this._offset; }\r\n\r\n    // The default Coerce function\r\n    static coerce(name: string, value: any): any {\r\n        let match = name.match(\"^u?int([0-9]+)$\");\r\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\r\n        return value;\r\n    }\r\n\r\n    coerce(name: string, value: any): any {\r\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\r\n        return Reader.coerce(name, value);\r\n    }\r\n\r\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\r\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\r\n        if (this._offset + alignedLength > this._data.length) {\r\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\r\n                alignedLength = length;\r\n            } else {\r\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\r\n                    length: this._data.length,\r\n                    offset: this._offset + alignedLength\r\n                });\r\n            }\r\n        }\r\n        return this._data.slice(this._offset, this._offset + alignedLength)\r\n    }\r\n\r\n    subReader(offset: number): Reader {\r\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\r\n    }\r\n\r\n    readBytes(length: number, loose?: boolean): Uint8Array {\r\n        let bytes = this._peekBytes(0, length, !!loose);\r\n        this._offset += bytes.length;\r\n        // @TODO: Make sure the length..end bytes are all 0?\r\n        return bytes.slice(0, length);\r\n    }\r\n\r\n    readValue(): BigNumber {\r\n        return BigNumber.from(this.readBytes(this.wordSize));\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}